const { dirname, basename, normalize } = require('path')
const { promisify } = require('util')

const glob = require('glob')
const { not: notJunk } = require('junk')
const precinct = require('precinct')
const requirePackageName = require('require-package-name')

const { getNestedDependencies, handleModuleNotFound } = require('./nested')
const { getPackageJson } = require('./package_json')
const { getPublishedFiles } = require('./published')
const { resolvePathPreserveSymlinks, resolvePackage } = require('./resolve')

const pGlob = promisify(glob)

// Retrieve the paths to the Node.js files to zip.
// We only include the files actually needed by the function because AWS Lambda
// has a size limit for the zipped file. It also makes cold starts faster.
const listNodeFiles = async function (srcPath, mainFile, srcDir, stat) {
  const [treeFiles, depFiles] = await Promise.all([getTreeFiles(srcPath, stat), getDependencies(mainFile, srcDir)])
  const files = [...treeFiles, ...depFiles].map(normalize)
  const uniqueFiles = [...new Set(files)]

  // We sort so that the archive's checksum is deterministic.
  // Mutating is fine since `Array.filter()` returns a shallow copy
  // eslint-disable-next-line fp/no-mutating-methods
  const filteredFiles = uniqueFiles.filter(isNotJunk).sort()
  return filteredFiles
}

// When using a directory, we include all its descendants except `node_modules`
const getTreeFiles = function (srcPath, stat) {
  if (!stat.isDirectory()) {
    return [srcPath]
  }

  return pGlob(`${srcPath}/**`, {
    ignore: `${srcPath}/**/node_modules/**`,
    nodir: true,
    absolute: true,
  })
}

// Remove temporary files like *~, *.swp, etc.
const isNotJunk = function (file) {
  return notJunk(basename(file))
}

// Retrieve all the files recursively required by a Node.js file
const getDependencies = async function (mainFile, srcDir) {
  const packageJson = await getPackageJson(srcDir)

  const state = { localFiles: new Set(), modulePaths: new Set() }

  try {
    return await getFileDependencies({ path: mainFile, packageJson, state })
  } catch (error) {
    error.message = `In file "${mainFile}"\n${error.message}`
    throw error
  }
}

const getFileDependencies = async function ({ path, packageJson, state, treeShakeNext }) {
  if (state.localFiles.has(path)) {
    return []
  }

  state.localFiles.add(path)

  const basedir = dirname(path)
  // This parses JavaScript in `path` to retrieve all the `require()` statements
  // TODO: `precinct.paperwork()` uses `fs.readFileSync()` under the hood,
  // but should use `fs.readFile()` instead
  const dependencies = precinct.paperwork(path, { includeCore: false })

  const depsPaths = await Promise.all(
    dependencies.map((dependency) => getImportDependencies({ dependency, basedir, packageJson, state, treeShakeNext })),
  )
  return [].concat(...depsPaths)
}

const getImportDependencies = function ({ dependency, basedir, packageJson, state, treeShakeNext }) {
  const shouldTreeShakeNext = treeShakeNext || isNextOnNetlify(dependency)
  if (shouldTreeShake(dependency, shouldTreeShakeNext)) {
    return getTreeShakedDependencies({ dependency, basedir, packageJson, state, treeShakeNext: shouldTreeShakeNext })
  }

  return getAllDependencies({ dependency, basedir, state, packageJson })
}

const isNextOnNetlify = function (dependency) {
  return basename(dependency, '.js') === 'renderNextPage'
}

// we tree shake direct local requires to bundle only relevant code
// we don't tree shake external dependencies since they can break our tree shaking logic by:
// 1. doing dynamic requires (e.g. require(dynamicPath))
// 2. reading files (e.g. fs.readFileSync(someNonJsFile))
// an exception is when the function was generated by `next-on-netlify` to avoid bundling the entire `Next.js` framework
const shouldTreeShake = function (dependency, treeShakeNext) {
  if (LOCAL_IMPORT_REGEXP.test(dependency)) {
    return true
  }

  return treeShakeNext && getModuleName(dependency) === 'next'
}

const LOCAL_IMPORT_REGEXP = /^(\.|\/)/

// When a file requires another one, we apply the top-level logic recursively
const getTreeShakedDependencies = async function ({ dependency, basedir, packageJson, state, treeShakeNext }) {
  const path = await resolvePathPreserveSymlinks(dependency, basedir)
  const depsPath = await getFileDependencies({ path, packageJson, state, treeShakeNext })
  return [path, ...depsPath]
}

// When a file requires a module, we find its path inside `node_modules` and
// use all its published files. We also recurse on the module's dependencies.
const getAllDependencies = async function ({ dependency, basedir, state, packageJson }) {
  const moduleName = getModuleName(dependency)

  // Happens when doing require("@scope") (not "@scope/name") or other oddities
  // Ignore those.
  if (moduleName === null) {
    return []
  }

  try {
    return await getModuleNameDependencies(moduleName, basedir, state)
  } catch (error) {
    return handleModuleNotFound({ error, moduleName, packageJson })
  }
}

// When doing require("moduleName/file/path"), only keep `moduleName`
const getModuleName = function (dependency) {
  const dependencyA = dependency.replace(BACKSLASH_REGEXP, '/')
  const moduleName = requirePackageName(dependencyA)
  return moduleName
}

// Windows path normalization
const BACKSLASH_REGEXP = /\\/g

const getModuleNameDependencies = async function (moduleName, basedir, state) {
  if (isExcludedModule(moduleName)) {
    return []
  }

  // Find the Node.js module directory path
  const packagePath = await resolvePackage(moduleName, basedir)

  if (packagePath === undefined) {
    return []
  }

  const modulePath = dirname(packagePath)

  if (state.modulePaths.has(modulePath)) {
    return []
  }

  state.modulePaths.add(modulePath)

  // The path depends on the user's build, i.e. must be dynamic
  // eslint-disable-next-line import/no-dynamic-require, node/global-require
  const packageJson = require(packagePath)

  const [publishedFiles, sideFiles, depsPaths] = await Promise.all([
    getPublishedFiles(modulePath),
    getSideFiles(modulePath, moduleName),
    getNestedModules(modulePath, state, packageJson),
  ])
  return [...publishedFiles, ...sideFiles, ...depsPaths]
}

const isExcludedModule = function (moduleName) {
  return EXCLUDED_MODULES.has(moduleName) || moduleName.startsWith('@types/')
}
const EXCLUDED_MODULES = new Set(['aws-sdk'])

// Some modules generate source files on `postinstall` that are not located
// inside the module's directory itself.
const getSideFiles = function (modulePath, moduleName) {
  const sideFiles = SIDE_FILES[moduleName]
  if (sideFiles === undefined) {
    return []
  }

  return getPublishedFiles(`${modulePath}/${sideFiles}`)
}

const SIDE_FILES = {
  '@prisma/client': '../../.prisma',
}

const getNestedModules = async function (modulePath, state, packageJson) {
  const dependencies = getNestedDependencies(packageJson)

  const depsPaths = await Promise.all(
    dependencies.map((dependency) => getAllDependencies({ dependency, basedir: modulePath, state, packageJson })),
  )
  return [].concat(...depsPaths)
}

module.exports = { listNodeFiles }
