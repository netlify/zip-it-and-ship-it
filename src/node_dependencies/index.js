const { dirname, basename, normalize } = require('path')

const { not: notJunk } = require('junk')
const precinct = require('precinct')
const requirePackageName = require('require-package-name')

const { getNestedDependencies, handleModuleNotFound } = require('./nested')
const { getPackageJson } = require('./package_json')
const { getPublishedFiles } = require('./published')
const { resolvePathPreserveSymlinks, resolvePackage } = require('./resolve')
const { getSideFiles } = require('./side_files')
const { getTreeFiles } = require('./tree_files')

// Retrieve the paths to the Node.js files to zip.
// We only include the files actually needed by the function because AWS Lambda
// has a size limit for the zipped file. It also makes cold starts faster.
const listNodeFiles = async function ({ srcPath, mainFile, srcDir, stat, pluginsModulesPath }) {
  const [treeFiles, depFiles] = await Promise.all([
    getTreeFiles(srcPath, stat),
    getDependencies(mainFile, srcDir, pluginsModulesPath),
  ])
  const files = [...treeFiles, ...depFiles].map(normalize)
  const uniqueFiles = [...new Set(files)]

  // We sort so that the archive's checksum is deterministic.
  // Mutating is fine since `Array.filter()` returns a shallow copy
  // eslint-disable-next-line fp/no-mutating-methods
  const filteredFiles = uniqueFiles.filter(isNotJunk).sort()
  return filteredFiles
}

// Remove temporary files like *~, *.swp, etc.
const isNotJunk = function (file) {
  return notJunk(basename(file))
}

// Retrieve all the files recursively required by a Node.js file
const getDependencies = async function (mainFile, srcDir, pluginsModulesPath) {
  const packageJson = await getPackageJson(srcDir)

  const state = { localFiles: new Set(), modulePaths: new Set() }

  try {
    return await getFileDependencies({ path: mainFile, packageJson, state, pluginsModulesPath })
  } catch (error) {
    error.message = `In file "${mainFile}"\n${error.message}`
    throw error
  }
}

const getFileDependencies = async function ({ path, packageJson, state, treeShakeNext, pluginsModulesPath }) {
  if (state.localFiles.has(path)) {
    return []
  }

  state.localFiles.add(path)

  const basedir = dirname(path)
  // This parses JavaScript in `path` to retrieve all the `require()` statements
  // TODO: `precinct.paperwork()` uses `fs.readFileSync()` under the hood,
  // but should use `fs.readFile()` instead
  const dependencies = precinct.paperwork(path, { includeCore: false })

  const depsPaths = await Promise.all(
    dependencies.map((dependency) =>
      getImportDependencies({ dependency, basedir, packageJson, state, treeShakeNext, pluginsModulesPath }),
    ),
  )
  return [].concat(...depsPaths)
}

const getImportDependencies = function ({
  dependency,
  basedir,
  packageJson,
  state,
  treeShakeNext,
  pluginsModulesPath,
}) {
  const shouldTreeShakeNext = treeShakeNext || isNextOnNetlify(dependency)
  if (shouldTreeShake(dependency, shouldTreeShakeNext)) {
    return getTreeShakedDependencies({
      dependency,
      basedir,
      packageJson,
      state,
      treeShakeNext: shouldTreeShakeNext,
      pluginsModulesPath,
    })
  }

  return getAllDependencies({ dependency, basedir, state, packageJson, pluginsModulesPath })
}

const isNextOnNetlify = function (dependency) {
  return basename(dependency, '.js') === 'renderNextPage'
}

// we tree shake direct local requires to bundle only relevant code
// we don't tree shake external dependencies since they can break our tree shaking logic by:
// 1. doing dynamic requires (e.g. require(dynamicPath))
// 2. reading files (e.g. fs.readFileSync(someNonJsFile))
// an exception is when the function was generated by `next-on-netlify` to avoid bundling the entire `Next.js` framework
const shouldTreeShake = function (dependency, treeShakeNext) {
  if (LOCAL_IMPORT_REGEXP.test(dependency)) {
    return true
  }

  return treeShakeNext && getModuleName(dependency) === 'next'
}

const LOCAL_IMPORT_REGEXP = /^(\.|\/)/

// When a file requires another one, we apply the top-level logic recursively
const getTreeShakedDependencies = async function ({
  dependency,
  basedir,
  packageJson,
  state,
  treeShakeNext,
  pluginsModulesPath,
}) {
  const path = await resolvePathPreserveSymlinks(dependency, [basedir, pluginsModulesPath].filter(Boolean))
  const depsPath = await getFileDependencies({ path, packageJson, state, treeShakeNext, pluginsModulesPath })
  return [path, ...depsPath]
}

// When a file requires a module, we find its path inside `node_modules` and
// use all its published files. We also recurse on the module's dependencies.
const getAllDependencies = async function ({ dependency, basedir, state, packageJson, pluginsModulesPath }) {
  const moduleName = getModuleName(dependency)

  // Happens when doing require("@scope") (not "@scope/name") or other oddities
  // Ignore those.
  if (moduleName === null) {
    return []
  }

  try {
    return await getModuleNameDependencies({ moduleName, basedir, state, pluginsModulesPath })
  } catch (error) {
    return handleModuleNotFound({ error, moduleName, packageJson })
  }
}

// When doing require("moduleName/file/path"), only keep `moduleName`
const getModuleName = function (dependency) {
  const dependencyA = dependency.replace(BACKSLASH_REGEXP, '/')
  const moduleName = requirePackageName(dependencyA)
  return moduleName
}

// Windows path normalization
const BACKSLASH_REGEXP = /\\/g

const getModuleNameDependencies = async function ({ moduleName, basedir, state, pluginsModulesPath }) {
  if (isExcludedModule(moduleName)) {
    return []
  }

  // Find the Node.js module directory path
  const packagePath = await resolvePackage(moduleName, [basedir, pluginsModulesPath].filter(Boolean))

  if (packagePath === undefined) {
    return []
  }

  const modulePath = dirname(packagePath)

  if (state.modulePaths.has(modulePath)) {
    return []
  }

  state.modulePaths.add(modulePath)

  // The path depends on the user's build, i.e. must be dynamic
  // eslint-disable-next-line import/no-dynamic-require, node/global-require
  const packageJson = require(packagePath)

  const [publishedFiles, sideFiles, depsPaths] = await Promise.all([
    getPublishedFiles(modulePath),
    getSideFiles(modulePath, moduleName),
    getNestedModules({ modulePath, state, packageJson, pluginsModulesPath }),
  ])
  return [...publishedFiles, ...sideFiles, ...depsPaths]
}

const isExcludedModule = function (moduleName) {
  return EXCLUDED_MODULES.has(moduleName) || moduleName.startsWith('@types/')
}
const EXCLUDED_MODULES = new Set(['aws-sdk'])

const getNestedModules = async function ({ modulePath, state, packageJson, pluginsModulesPath }) {
  const dependencies = getNestedDependencies(packageJson)

  const depsPaths = await Promise.all(
    dependencies.map((dependency) =>
      getAllDependencies({ dependency, basedir: modulePath, state, packageJson, pluginsModulesPath }),
    ),
  )
  return [].concat(...depsPaths)
}

module.exports = { listNodeFiles }
